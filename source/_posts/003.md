---
title: 基础算法而已
date: 2021-09-17 17:25:13
tags:
  - [排序算法]
  - [acwing]
categories:
  - [算法]

---

算法入门：啊哈算法 算法图解 大话数据结构

算法进阶：cf 白书 紫书 蓝书

## 第一章 基础算法

### 基础算法(一)

#### 排序

- 含义:排序是指将一个无序序列按照某个规则进行有序排列(以下排序均实现的是从小到大排序)

##### 简单排序

- 冒泡排序的本质在于==交换== ，即每次通过交换的方式把当前剩余元素的最大值移动到一端

  ```c++
  # 冒泡排序(以下实现从小到大排序)
  int a[n]={......};
  for(int i=1;i<n;i++){  //进行n-1躺
  	//第i躺，从a[0]-a[n-i-1]每一个数都要与下一个数进行比较，遇到后面比自己较大的数就交换，实现每一趟剩余的数a[0]-a[n-		i]的冒泡排序，使当前a[0]~a[n-i]中的最大的元素移动到z'y，后面的a[n-i+1]-a[i]已经排好序
      for(int i=0;j< n-i;j++){
          if(a[j] > a[j+1]){  //如果左边的数更大，则a[j]与a[j+1]交换
              int temp = a[j];
              a[j] = a[j+1];
              a[j+1] = temp;
          }
      }
  }
  ```

- (简单)选择排序：

  ```c++
  # 选择排序(以下实现从小到大排序)
  # 简单选择排序是指对一个序列a[n]中的元素a[1]~a[n]，令i从1~n进行枚举，进行n趟操作，每趟从待排序部分[i,n]其中选择最小的元素，令其与待排部分的第一个元素a[i]进行交换，这样元素a[i]就会与当前区间[1,i-1]形成新的有序区间[1,i],n趟操作以后，就形成有序区间
  int a[n]={......};
  void select_sort(){
      for(int i=1;i<=n;i++){  //进行n趟操作
          int k = i;
          for(int j=i;j<=n;j++){  //选出[i,n]中最小元素的下标，并且将下标记为k
              if(a[j]<a[k]){
                  k = j;
              }
          }
          int temp = a[i];  //交换a[k]与当前待排序序列[i,n]的第一个元素a[i]
          a[i] = a[k];
          a[j] = temp;
      }
  }
  ```

  

- (直接)插入排序：

  ```c++
  # 直接插入排序
  # 直接插入排序是指对序列a[n]中的元素a[i]~a[n]，i从2~n进行枚举，进行n-1趟操作。假设某一趟，序列a[1]~a[i-1]已经有序，那么这一次就是从范围[1,i-1]中寻找某个位置j,使得a[i]插入到这个位置j后，此时a[j]~a[i-1]会自动向后移动一位到a[j+1]~a[i],范围a[1,i]有序
  int a[n]={......};  //n为元素个数，数组下标为1~n
  void insert_sort(){
      for(int i=2;i<=n;i++){  //进行n-1趟排序
          int temp = a[i],j = i; //temp临时存放a[i]
          while(j>1 && temp<a[j-1]){
              a[j] = a[j-1];
              j--;
          }
          a[j] = temp;
      }
  }
  ```

  

##### 快排

- 快排的主要思想是分治

  ```c++
  //快排的时间复杂度是nlogn(这里所指的是平均复杂度)
  #include <iostream>
  
  acwing 785快速排序
  
  using namespace std;
  
  const int N = 1e6+10;
  
  int n;
  int q[N];
  
  void quick_sort(int q[], int l, int r)
  {
      if (l >= r) return;
  
      int i = l - 1, j = r + 1, x = q[l + r >> 1];  //x的取值可以取区间里面任意一个
      while (i < j)
      {
          do i ++ ; while (q[i] < x);
          do j -- ; while (q[j] > x);
          if (i < j) swap(q[i], q[j]);
      }
      quick_sort(q, l, j); //对左边的进行快排
      quick_sort(q, j + 1, r); //对右边进行快排
  }
  
  int main(){
  	scanf("%d",&n);
      for(int i=0;i<n;i++){
          scanf("%d",&q[i]);
      }
      quick_sort(q,0,n-1);
      
      for(int i=0;i<n;i++){
          printf("%d ",q[i]);
      }
  }
  ```


##### 归并排序

- 归并的主要思想也是分治

  ```c++
  acwing787 归并排序
  
  #include <iostream>
  
  using namespace std;
  
  const int N = 1e6+10;
  
  int n;
  int q[N];
  int tmp[N];
  
  void merge_sort(int q[],int l,int r){
      if(l>=r) return ;
      
      int mid = l+r >> 1;  //1：确定分界点
      
      merge_sort(q,l,mid);   //对左右两边分别进行归并排序
      merge_sort(q,mid+1,r);
      
      // 将左右两边进行归并排序，把两个有序的序列拼接在一起，拼接的方法就是归并
      int k=0,i=l,j=mid+1; 
      while(i<=mid && j<= r){
          if(q[i]<=q[j]) tmp[k++] = q[i++];
          else tmp[k++] = q[j++];
      }
      while(i<=mid) tmp[k++]=q[i++];  //对于q[l]~[mid]和q[mid+1~r]两个序列，如果存在序列没有循环结束的话就直接								到tmp序列后面即可
      while(j<=r) tmp[k++]=q[j++];
      
      for(i=l,j=0;i <= r;i++,j++) q[i] = tmp[j];
  }
  int main(){
      scanf("%d",&n);
      for(int i=0;i<n;i++) scanf("%d",&q[i]);
      
      merge_sort(q,0,n-1);
      
      for(int i=0;i<n;i++) printf("%d ",q[i]);
      
      return 0;
  }
  ```


#### 二分

##### 整数

- 整数二分的本质:有单调性的话一定可以二分；但是能二分的不一定具有单调性
  二分的本质是对于一个整数区间，我们先定义一个性质，要找到一个中间点，是的在这个点的右半边满足这个性质，左半边不满足这个性质，这样就可以把一个区间一分为二，找到这个边界

  ```c++
  #1.找到一个中间值mid
  # if(check(mid)) true:mid满足这个性质  false:mid不满足这个性质
  # 二分的时候一定要保证要寻找的值一定在不断缩小的那个区间里面，当区间的长度为1的时候就代表找到答案
  
  #acwing789:数的范围
  
  #include <iostream>
  #include <algorithm>
  #include <cstring>
  
  using namespace std;
  
  const int N=100010;
  
  int a,b;
  int q[N];
  
  int main(){
      scanf("%d %d",&a,&b);
      for(int i=0;i<a;i++) scanf("%d",&q[i]);
      
      while(b--){
          int x;
          scanf("%d",&x);
          
          int l=0,r=a-1;
          while(l<r){
              int mid= l+r >> 1;
              if(q[mid]>=x) r=mid;
              else l=mid+1;
          }
          
          if(q[l]!=x) cout<<"-1 -1"<<endl;  // 这个表示要寻找的那个值不在区间里面，此时q[l]的值是第一个满足大于x的数
          else{
              cout<<l<<' ';
              
              int l=0,r=a-1;
              while(l<r){
              	int mid= l+r+1 >> 1;
              	if(q[mid]<=x) l=mid;
              	else r=mid-1;
              }
              cout<<l
          }
      }
  	return 0;
  }
  ```

  

##### 浮点数

- 浮点数二分:本质上也是寻找边界，满足左半边满足性质，右半边不满足性质，知道

- ```c++
  # 例子:算平方根
  
  #include <iostream>
  
  using namespace std;
  
  int mian(){
      double x;
      cin>>x;
      
      double l=0,r=x;
      double mid = (l+r)/2;
      while(r-l > 1e-8){
          if(mid*mid>=x)  r=mid;
          else l=mid;
      }
      
      printf("%lf",&l);
  }
  ```

  

